using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;
using TMPro;
using UnityEngine.SceneManagement;
using UnityEngine.Networking;
using System;
using System.IO;
using System.Linq;


public class PlayerController : MonoBehaviour
{
    public static PlayerController playerControl;
    public DataConverter dataConverter;
    public Topsis topsis;
    private Rigidbody2D rb;
    private Animator anim;
    private Collider2D coll;

    [SerializeField] private LayerMask rightAnswer;
    [SerializeField] private LayerMask wrongAnswer;

    // Player movement
    [SerializeField] private LayerMask ground;
    [SerializeField] private float speed = 7f;
    [SerializeField] private float jumpforce = 7f;
    [SerializeField] private float hurtforce = 7f;
    [SerializeField] private bool facingRight = true;

    [SerializeField] private float respawnDelay;
    [SerializeField] private Vector3 respawnPoint;
    [SerializeField] private Vector3 positionBefore;
    private enum State
    { idle, running, jumping, falling, hurt, squat, masuk }
    private State state = State.idle;
    // test
    // [SerializeField] private GameObject[] book;

    // Players power
    private PowerController powerController;

    // TIME
    private float timeDuration = 60;
    private float timer;

    // Time GUI
    [SerializeField] private TextMeshProUGUI firstMinute;
    [SerializeField] private TextMeshProUGUI secondMinute;
    [SerializeField] private TextMeshProUGUI separator;
    [SerializeField] private TextMeshProUGUI firstSecond;
    [SerializeField] private TextMeshProUGUI secondSecond;

    // private float flashTimer;
    // private float flashDuration = 1f;

    // Question Property
    static private int stateBook = 0;
    private int status = 0;
    private static int materi_id = 0;
    static public bool stat;

    // Coin GUI
    [SerializeField] private TextMeshProUGUI arrowText;

    // Health
    [SerializeField] private GameObject lives;
    private int liveCount = 0;
    [SerializeField] private TextMeshProUGUI liveText;

    // Soal
    // [SerializeField]
    // static List<int> i_store = new List<int>();
    // [SerializeField]
    // private string[] soal_materi;

    // TOPSIS pre-test data
    private bool answer;
    private float timeFinish;
    private float time_finish_conv;
    [SerializeField]
    private int jumlah_soal;
    [SerializeField]
    private static float skor1, skor2, skor3;
    [SerializeField]
    private static float time1, time2, time3;
    private int experience1, experience2, experience3;
    private float skor_mat1, skor_mat2, skor_mat3;
    private float time_mat1, time_mat2, time_mat3;
    [SerializeField]
    private int pretest_stat;

    // TOPSIS Var
    private string[] alternatif;
    private static float[] score, time;
    private float[] times;
    private int[] experience;

    [SerializeField]
    private string c1_category, c2_category, c3_category;

    private void Start()
    {
        rb = GetComponent<Rigidbody2D>();
        anim = GetComponent<Animator>();
        // popup = GetComponent<Animator>();
        coll = GetComponent<Collider2D>();
        powerController = GetComponent<PowerController>();
        dataConverter = GetComponent<DataConverter>();
        topsis = GetComponent<Topsis>();
        // Load();
        // arrowText.text = coins.ToString();
        // print("start");
        // print(skor1);

    }

    // void Awake()
    // {
    //     if (stat == true)
    //     {
    //         stat = false;
    //         ambilSoal();
    //     }
    // }


    private void Update()
    {
        // coins = totalCoin;
        // if (stat == true)
        // {
        //     stat = false;
        //     ambilSoal();
        // }
        if (Input.GetButtonDown("test1"))
        {
            SceneManager.LoadScene("scene1lv1");
            transform.position = respawnPoint;
        }
        if (state != State.hurt)
        {
            Movement();
        }
        AnimationState();
        anim.SetInteger("state", (int)state);

        // Code- Start timer in question
        if (stateBook == 1)
        {
            // print(timer);
            if (timer > 0)
            {
                // print("timerCounter");
                timer -= Time.deltaTime;

                UpdateTimerDisplay(timer);
            }
            else
            {
                // flash();
            }
        }
        // Code- Score calculation
        if (Input.GetButtonDown("Submit") && stateBook == 1 && coll.IsTouchingLayers(rightAnswer))
        {
            answer = true;
            // print("submit right answer");
            // lives.SetActive(true);
            // timeFinish = getTimeValue();
            switch (materi_id)
            {
                case 1:
                    skor1 = skor1 + 70;
                    time1 += timeFinish;
                    break;
                case 2:
                    skor2 += 70;
                    time2 += timeFinish;
                    break;
                case 3:
                    skor3 += 70;
                    time3 += timeFinish;
                    break;
                default:
                    break;
            }
            print(skor1);
            // answer = true;
            // stateBook = 0;
            powerController.getWeapon(true);
            liveCount += 1;

            // SET TAG/LAYER POPUP & ANSWER TO FALSE
            // PopUpQuest.SetActive(false);
            // Answer1.SetActive(false);
        }
        if (Input.GetButtonDown("Submit") && stateBook == 1 && coll.IsTouchingLayers(wrongAnswer))
        {
            answer = false;
            // print("submit wrong answer");
            // timeFinish = getTimeValue();

            switch (materi_id)
            {
                case 1:
                    skor1 = skor1 + 1;
                    time1 += timeFinish;
                    // print("SKOR1: " + skor1);
                    print("time1: " + time1);
                    break;
                case 2:
                    skor2 += 1;
                    time2 += timeFinish;
                    // print("SKOR1: " + skor2);
                    print("time2: " + time2);
                    break;
                case 3:
                    skor3 += 1;
                    time3 += timeFinish;
                    print("time3: " + time3);
                    break;
                default:
                    break;
            }
            print(skor1);

            // stateBook = 0;
            // // SET TAG/LAYER POPUP & ANSWER TO FALSE
            // // PopUpQuest.SetActive(false);
            // // Answer1.SetActive(false);
            // ResetTimer();
        }

        if (pretest_stat == 1)
        {
            pretest_stat = 0;
            float[] final_score = dataConverter.ScoreConvert(skor1, skor2, skor3);
            float[] final_time = dataConverter.TimeConvert(time1, time2, time3);

            topsis.topsis_calculate(final_score, final_time);
            // times = new float[3] { time1, time2, time3 };
            // topsis_calculate();
        }
    }

    private void Movement()
    {
        float hDirection = Input.GetAxis("Horizontal");

        if (hDirection != 0)
        {
            rb.velocity = new Vector2(hDirection * speed, rb.velocity.y);

        }
        if (hDirection < 0 && facingRight)
        {
            flip();
            // transform.Rotate (0f, 180f, 0f);

            // transform.localScale = new Vector2(-1, 1);
        }

        else if (hDirection > 0 && !facingRight)
        {
            flip();
            // rb.velocity = new Vector2(hDirection * speed, rb.velocity.y);
            // transform.localScale = new Vector2(1, 1);
        }

        if (Input.GetButtonDown("Jump") && (coll.IsTouchingLayers(ground) || coll.IsTouchingLayers(rightAnswer) || coll.IsTouchingLayers(wrongAnswer)))
        {
            Jump();
        }
        if (Input.GetButtonDown("Down"))
        {
            rb.velocity = new Vector2(rb.velocity.x, .1f);
            state = State.squat;
        }
    }

    void flip()
    {
        Vector3 currentScale = gameObject.transform.localScale;

        // currentScale.x *= -1;
        transform.Rotate(0f, 180f, 0f);

        // gameObject.transform.localScale = currentScale;

        facingRight = !facingRight;
    }

    private void Jump()
    {
        rb.velocity = new Vector2(rb.velocity.x, jumpforce);
        state = State.jumping;
    }

    private void AnimationState()
    {
        if (state == State.jumping)
        {
            if (rb.velocity.y < .1f)
            {
                state = State.falling;
            }
        }
        else if (state == State.falling)
        {
            if (coll.IsTouchingLayers(ground) || coll.IsTouchingLayers(rightAnswer) || coll.IsTouchingLayers(wrongAnswer))
            {
                state = State.idle;
            }
        }
        else if (state == State.hurt)
        {
            if (Mathf.Abs(rb.velocity.x) < .1f)
            {
                state = State.idle;
            }
        }
        else if (Mathf.Abs(rb.velocity.x) > 2f)
        {
            state = State.running;
        }
        else if (state == State.squat)
        {
            if (rb.velocity.y < .1f)
            {
                state = State.idle;
            }
        }
        else
        {
            state = State.idle;
        }
    }

    // public int getCoins()
    // {
    //     // coins = int.Parse(arrowText.text);
    //     print("Coins = " + coins);
    //     return coins;
    // }

    private void OnTriggerEnter2D(Collider2D collision)
    {
        if (collision.tag == "book")
        {
            materi_id = 1;
            stat = true;

            // respawnPoint = this.transform.position;

            SceneManager.LoadScene("Gelap");

            stateBook = 1;
            Destroy(collision.gameObject);
            // for (int i = 0; i < 1; i++)
            // {
            //     ambilSoal();
            // }
            /* cek pendeklarasian variabel
            // print("Materi ID: " + materi_id);
*/

        }
        if (collision.tag == "book2")
        {
            materi_id = 1;
            // PopUp2.SetActive(PopingUp);
            // Answer2.SetActive(PopingUp);
            Destroy(collision.gameObject);
            ResetTimer();
            stateBook = 1;

        }
        if (collision.tag == "book3")
        {
            materi_id = 2;

            // PopUp3.SetActive(PopingUp);
            // Answer3.SetActive(PopingUp);
            Destroy(collision.gameObject);
            ResetTimer();
            stateBook = 1;
        }
        if (collision.tag == "Collectable")
        {
            Destroy(collision.gameObject);
            // coins = sceneWin
            // coins = int.Parse(arrowText.text);
            // coins += 1;
            // arrowText.text = coins.ToString();
        }
        // if (collision.tag == "Health")
        // {
        //     // healthlife.Play();
        //     Destroy(collision.gameObject);
        //     health += 1;
        //     healthText.text = health.ToString();
        // }
        if (collision.tag == "checkpoint")
        {
            respawnPoint = transform.position;
        }
        // if (collision.IsTouchingLayers(rightAnswer))
        // {
        //     answer = true;
        // }
    }

    //private IEnumerator ResetPopUp()
    //{
    //    yield return new WaitForSeconds(5);
    //    PopingUp = false;
    //}

    void OnCollisionEnter2D(Collision2D other)
    {
        //     if (other.gameObject.tag == "Enemy")
        //     {
        //         if (state == State.falling)
        //         {
        //             Destroy(other.gameObject);
        //             Jump();
        //             getCoins();
        //         }
        //         else
        //         {
        //             state = State.hurt;
        //             if (other.gameObject.transform.position.x < transform.position.x)
        //             {
        //                 rb.velocity = new Vector2(hurtforce + 1, 5);
        //             }
        //             else
        //             {
        //                 rb.velocity = new Vector2(-hurtforce - 2, 5);
        //             }
        //             loseCoins();
        //         }
        //     }
        // }
        // void loseCoins()
        // {
        //     coins -= 3;
        //     arrowText.text = coins.ToString();
        //     if (coins <= 0)
        //     {
        //         SceneManager.LoadScene("scene1lv1");
        //     }
    }

    private void ResetTimer()
    {
        // print("ResetTimer");
        timer = timeDuration;
    }
    private void UpdateTimerDisplay(float time)
    {
        // ~ UNTUK TIMER
        float minutes = Mathf.FloorToInt(time / 60);
        float seconds = Mathf.FloorToInt(time % 60);

        string currentTime = string.Format("{00:00}{1:00}", minutes, seconds);
        firstMinute.text = currentTime[0].ToString();
        secondMinute.text = currentTime[1].ToString();
        firstSecond.text = currentTime[2].ToString();
        secondSecond.text = currentTime[3].ToString();
    }
    private float getTimeValue()
    {
        // ~ KONVERSI WAKTU SESUAI SKALA PENILAIAN
        if (timer > 40)
        {
            time_finish_conv = 30;
            // print("yang pertama");
        }
        else if (timer < 40 && timer > 20)
        {
            time_finish_conv = 20;
        }
        else if (timer < 20)
        {
            time_finish_conv = 10;

        }
        return time_finish_conv;
    }

    // public void ambilSoal()
    // {
    //     // print(soal_materi.Length);
    //     int i = UnityEngine.Random.Range(0, soal_materi.Length);

    //     if (i_store.Count >= soal_materi.Length)
    //     {
    //         i_store.Clear();
    //     }

    //     int i_fix = cekDuplicate(i);

    //     foreach (int item in i_store)
    //     {
    //         print(item);
    //     }
    //     print(soal_materi[i_fix]);
    //     soalText.SetText(soal_materi[i_fix].ToString());
    // soalText.text = soal_materi[i_fix];
    // print(soal_materi[i_fix].ToString());
    // soalText.text = "Soal baru";
    // print(soalText);

    // correctAnswer = answerValues[i];

    // }
    // public void Load()
    // {
    //     if (File.Exists(Application.dataPath + "/data/soal_materi_1.txt"))
    //     {
    //         soal_materi = File.ReadAllLines(Application.dataPath + "/data/soal_materi_1.txt");
    //         // BinaryFormatter bf = new BinaryFormatter();

    //         // FileStream file = File.Open(Application.dataPath + "/data/soal_materi_1.txt", FileMode.Open);
    //         // PTInfo data = (PTInfo)bf.Deserialize(file);

    //         // file.Close();

    //         // elementsNames = data.elementsNames;
    //         // answerValues = data.answerValues;
    //     }
    // }
    // public int cekDuplicate(int i)
    // {
    //     // print(elementsNames.Length.GetType());
    //     if (i_store.Count < 1 || i_store.Count == soal_materi.Length - 1)
    //     {
    //         i_store.Add(i);
    //     }
    //     else
    //     {
    //         // print("cek duplicate foreach " + last_i);
    //         if (!i_store.Contains(i))
    //         {
    //             i_store.Add(i);
    //             // print("cek duplicate foreach if");
    //         }
    //         else
    //         {
    //             // print("cek duplicate else");
    //             int new_i = UnityEngine.Random.Range(0, 7);
    //             cekDuplicate(new_i);
    //         }
    //     }
    //     return i;
    // }
    // private void getWeapon(bool answer)
    // {
    //     arrow += 1;
    // }

    private void topsis_calculate()
    {
        alternatif = new string[3] { "materi 1", "materi 2", "materi 3" };

        // ~ INI CONTOH DATANYA, SOALNYA BELUM BISA NGAMBIL DATA PENGALAMAN
        // experience1 = 1;
        // experience2 = 2;
        // experience3 = 3;

        // skor_mat1 = skor1 / jumlah_soal;
        // // print(skor1 + "/" + jumlah_soal + "=" + skor_mat1);
        // skor_mat2 = skor2 / jumlah_soal;
        // // print("2 = " + skor_mat2);
        // skor_mat3 = skor3 / jumlah_soal;
        // // print("3 = " + skor_mat3);
        // time_mat1 = time1 / jumlah_soal;
        // // print(skor1 + "/" + jumlah_soal + "=" + skor_mat1);
        // time_mat2 = time2 / jumlah_soal;
        // // print("2 = " + skor_mat2);
        // time_mat3 = time3 / jumlah_soal;
        // // print("3 = " + skor_mat3);


        // mengambil data pre-test
        score = new float[3] { skor_mat1, skor_mat2, skor_mat3 };
        time = new float[3] { time1, time2, time3 };
        experience = new int[3] { experience1, experience2, experience3 };

        // INI CONTOH DATA
        //     // score = new float[3] { 1, 1, 70 };
        //     // time = new float[3] { 16, 14, 20 };
        //     // experience = new int[3] { 3, 2, 1 };

        //     // ~ VARIABEL YANG DIBUTUHKAN. DI SINI SETIAP KRITERIA DI PISAH DALAM ARRAY, JADI BENTUKNYA BUKAN DECISION MATRIX SEPERTI BIASA
        float sum_c1 = 0;
        float sum_c2 = 0;
        float sum_c3 = 0;
        float norm_div_c1;
        float norm_div_c2;
        float norm_div_c3;
        float[] norm_c1 = new float[score.Length];
        float[] norm_c2 = new float[time.Length];
        float[] norm_c3 = new float[experience.Length];
        float topsis_ips_c1 = 0;
        float topsis_ips_c2 = 0;
        float topsis_ips_c3 = 0;
        float topsis_ins_c1 = 0;
        float topsis_ins_c2 = 0;
        float topsis_ins_c3 = 0;
        float[] topsis_dp = new float[alternatif.Length];
        float[] topsis_dn = new float[alternatif.Length];
        float[] topsis_sum_dp = new float[alternatif.Length];
        float[] topsis_sum_dn = new float[alternatif.Length];
        float val = 0;

        // ~ INI VARIABEL DICTIONARY UNTUK PERANKINGAN
        Dictionary<string, float> topsis_v = new Dictionary<string, float>();


        // NORMALISASI C1
        for (int i = 0; i < score.Length; i++)
        {
            print("score" + i + " = " + score[i]);
            sum_c1 += (score[i] * score[i]);
            print("Sum c1 = " + sum_c1);
        }

        norm_div_c1 = Mathf.Sqrt(sum_c1);
        print("norm div1 = " + norm_div_c1);

        for (int i = 0; i < score.Length; i++)
        {
            norm_c1[i] = (score[i] / norm_div_c1);
        }
        // // UNTUK LIAT HASIL NORMALISASI C1
        // foreach (var item1 in norm_c1)
        // {
        //     print("normalisasi c1 = " + item1);
        // }

        // ~ NORMALISASI C2
        for (int i = 0; i < time.Length; i++)
        {
            print("time" + i + " = " + time[i]);
            sum_c2 += (time[i] * time[i]);
            print("Sum c2= " + sum_c2);
        }

        norm_div_c2 = Mathf.Sqrt(sum_c2);
        print("norm div3" + norm_div_c2);

        for (int i = 0; i < time.Length; i++)
        {
            norm_c2[i] = (time[i] / norm_div_c2);
        }
        // // UNTUK LIAT HASIL NORMALISASI C2
        // foreach (var item2 in norm_c2)
        // {
        //     print("normalisasi c2" + item2);
        // }

        // ~ NORMALISASI C3
        for (int i = 0; i < experience.Length; i++)
        {
            print("experience" + i + " = " + experience[i]);
            sum_c3 += (experience[i] * experience[i]);
            print("Sum c3" + sum_c3);
        }

        norm_div_c3 = Mathf.Sqrt(sum_c3);
        print("norm div3" + norm_div_c3);

        for (int i = 0; i < experience.Length; i++)
        {
            norm_c3[i] = (experience[i] / norm_div_c3);
        }
        // // UNTUK LIAT HASIL NORMALISASI C3
        // foreach (var item3 in norm_c3)
        // {
        //     print("normalisasi c3" + item3);
        // }

        // ~ NORMALISASI TERBOBOT PER KATEGORI
        float[] norm_weight_c1 = new float[score.Length];
        float[] norm_weight_c2 = new float[time.Length];
        float[] norm_weight_c3 = new float[experience.Length];
        for (int j = 0; j < score.Length; j++)
        {
            norm_weight_c1[j] = (norm_c1[j] * 0.5f);
            print("norm weight1 " + norm_weight_c1[j]);
        }
        for (int j = 0; j < time.Length; j++)
        {
            norm_weight_c2[j] = (norm_c2[j] * 0.3f);
            print("norm weight2 " + norm_weight_c2[j]);
        }
        for (int j = 0; j < experience.Length; j++)
        {
            norm_weight_c3[j] = (norm_c3[j] * 0.2f);
            print("norm weight3 " + norm_weight_c3[j]);
        }

        // ~ SOLUSI IDEAL POSITIF PERKATEGORI
        if (c1_category == "benefit")
        {
            topsis_ips_c1 = Mathf.Max(norm_weight_c1);
        }
        else if (c1_category == "cost")
        {
            topsis_ips_c1 = Mathf.Min(norm_weight_c1);
        }
        print("ideal positif1 = " + topsis_ips_c1);

        if (c2_category == "benefit")
        {
            topsis_ips_c2 = Mathf.Max(norm_weight_c2);
        }
        else if (c2_category == "cost")
        {
            topsis_ips_c2 = Mathf.Min(norm_weight_c2);
        }
        print("ideal positif2 = " + topsis_ips_c2);

        if (c3_category == "benefit")
        {
            topsis_ips_c3 = Mathf.Max(norm_weight_c3);
        }
        else if (c3_category == "cost")
        {
            topsis_ips_c3 = Mathf.Min(norm_weight_c3);
        }
        print("ideal positif3 = " + topsis_ips_c3);

        // ~ SOLUSI IDEAL NEGATIF
        if (c1_category == "benefit")
        {
            topsis_ins_c1 = Mathf.Min(norm_weight_c1);
        }
        else if (c1_category == "cost")
        {
            topsis_ins_c1 = Mathf.Max(norm_weight_c1);
        }
        print("ideal negatif1 = " + topsis_ins_c1);

        if (c2_category == "benefit")
        {
            topsis_ins_c2 = Mathf.Min(norm_weight_c2);
        }
        else if (c2_category == "cost")
        {
            topsis_ins_c2 = Mathf.Max(norm_weight_c2);
        }
        print("ideal negatif2 = " + topsis_ins_c2);

        if (c3_category == "benefit")
        {
            topsis_ins_c3 = Mathf.Min(norm_weight_c3);
        }
        else if (c3_category == "cost")
        {
            topsis_ins_c3 = Mathf.Max(norm_weight_c3);
        }
        print("ideal negatif3 = " + topsis_ins_c3);

        // ~ JARAK EUCLIDEAN ALTERNATIF KE SOLUSI IDEAL POSITIF
        for (int i = 0; i < alternatif.Length; i++)
        {
            topsis_sum_dp[i] = ((topsis_ips_c1 - norm_weight_c1[i]) * (topsis_ips_c1 - norm_weight_c1[i]));
            topsis_sum_dp[i] += ((topsis_ips_c2 - norm_weight_c2[i]) * (topsis_ips_c2 - norm_weight_c2[i]));
            topsis_sum_dp[i] += ((topsis_ips_c3 - norm_weight_c3[i]) * (topsis_ips_c3 - norm_weight_c3[i]));
        }
        for (int i = 0; i < alternatif.Length; i++)
        {
            topsis_dp[i] = Mathf.Sqrt(topsis_sum_dp[i]);
            print("pos [ " + topsis_dp[i] + "]");
        }

        // ~ JARAK EUCLIDEAN ALTERNATIF KE SOLUSI IDEAL NEGATIF
        for (int j = 0; j < alternatif.Length; j++)
        {
            topsis_sum_dn[j] = ((topsis_ins_c1 - norm_weight_c1[j]) * (topsis_ins_c1 - norm_weight_c1[j]));
            topsis_sum_dn[j] += ((topsis_ins_c2 - norm_weight_c2[j]) * (topsis_ins_c2 - norm_weight_c2[j]));
            topsis_sum_dn[j] += ((topsis_ins_c3 - norm_weight_c3[j]) * (topsis_ins_c3 - norm_weight_c3[j]));
        }
        for (int j = 0; j < alternatif.Length; j++)
        {
            topsis_dn[j] = Mathf.Sqrt(topsis_sum_dn[j]);
            print("neg [ " + topsis_dn[j] + "]");
        }

        // ~ NILAI PREFERENSI
        for (int i = 0; i < alternatif.Length; i++)
        {
            val = (topsis_dn[i] / (topsis_dp[i] + topsis_dn[i]));
            print("Nilai preferensi materi  " + i + " = " + val);
            // Memasukkan ke dictionary dengan key = nomor materi, value = nilai preferensi
            topsis_v.Add(alternatif[i], val);
        }

        // ~ PENGURUTAN DARI YANG TERBESAR
        int r = 1;
        var sortedKeyValuePairs = topsis_v.OrderByDescending(x => x.Value).ToList();
        foreach (var items in sortedKeyValuePairs)
        {

            print("Ranking " + (r++) + " = materi " + items.Key + " (" + items.Value + ")");
        }

    }


}

// ~ BUKAN BAGIAN DARI KODINGAN
// IEnumerator getSoalValue()
// {
// string url = "https:\\localhost\database\getSoalData.php";
// }
/*
    ALUR PERHITUNGAN TOPSIS

1. membuat matriks keputusan
keterangan: 
i = baris
j = kolom

    // float [,] dm = new float (,);

    // ambil data pengalaman
    int experience [] = {}
    int nilai [] = {}
    int waktu [] = {}
    // ambil nilai
    // ambil waktu

    for (j = 0; j<jumlah variabel; j++){
        for (i = 0; i<jumlah materi; i++)

        switch (j){
            case 0:
                dm[i, j] = score [i];
                break;
            case 1:
                dm[i, j] = time [i];
                break;
            case 2:
                dm[i, j] = experience[i];
                break;
            default:
                break;
        }
    }    

2. normalisasi matriks keputusan
    //menentukan nilai pembagi yaitu akar (penjumlahan (rating alt ^ 2) ) di setiap kriteria
    // sum semua rating alt kriteria 1 ^2
        for (int i = 0; i<score.length ; i++){
            dm_sum_c1 += (score[i]*score[i]);
        }
    // pake library Math
    dm_norm_div_c1 = Math.Sqrt (dm_sum_c1);

    // membagi nilai dengan pembagi
    float dm_norm [,] = new float [,];
    for (int i = 0; i<score.length ; i++){
        dm_norm [i,0] = (score [i]/dm_norm_div_c1);
    }

    // sum semua rating alt kriteria 2 ^2
        for (int i = 0; i<time.length ; i++){
            dm_sum_c2 += (time[i]*time[i]);
        }
    // pake library Math
    dm_norm_div_c2 = Math.Sqrt (dm_sum_c2);

    // membagi nilai dengan pembagi
    float dm_norm [,] = new float [,];
    for (int i = 0; i<time.length ; i++){
        dm_norm [i,1] = (time [i]/dm_norm_div_c2);
    }

    // sum semua rating alt kriteria 3 ^2
        for (int i = 0; i<experience.length ; i++){
            dm_sum_c3 += (experience[i]*experience[i]);
        }
    // pake library Math
    dm_norm_div_c3 = Math.Sqrt (dm_sum_c3);

    // membagi nilai dengan pembagi
    float dm_norm [,] = new float [,];
    for (int i = 0; i<experience.length ; i++){
        dm_norm [i,2] = (experience [i]/dm_norm_div_c2);
    }

3. normalisasi matriks keputusan terbobot
    for (j = 0; j<jumlah variabel; j++){
        for (i = 0; i<jumlah materi; i++)

        switch (j){
            case 0:
                dm_norm_weight[i, j] = (dm_norm [i,j] * 0.5);
                break;
            case 1:
                dm_norm_weight[i, j] = (dm_norm [i,j] * 0.3);
                break;
            case 2:
                dm_norm_weight[i, j] = (dm_norm [i,j] * 0.2);
                break;
            default:
                break;
        }
    }   
4. solusi ideal positif
    // cek kategori kriteria
    if (c1_category == "benefit"){
        topsis_ips_c1 =  Math.Max (score_norm_weight)
    }else{
        topsis_ips_c1 =  Math.Min (score_norm_weight)
    }
    if (c2_category == "benefit"){
        topsis_ips_c2 =  Math.Max (time_norm_weight)
    }else{
        topsis_ips_c2 =  Math.Min (time_norm_weight)
    }
    if (c3_category == "benefit"){
        topsis_ips_c3 =  Math.Max (experience_norm_weight)
    }else{
        topsis_ips_c3 =  Math.Min (experience_norm_weight)
    }

5. solusi ideal negatif
// cek kategori kriteria
    if (c1_category == "benefit"){
        topsis_ins_c1 =  Math.Min (score_norm_weight)
    }else{
        topsis_ins_c1 =  Math.Max (score_norm_weight)
    }
    if (c2_category == "benefit"){
        topsis_ins_c2 =  Math.Min (time_norm_weight)
    }else{
        topsis_ins_c2 =  Math.Max (time_norm_weight)
    }
    if (c3_category == "benefit"){
        topsis_ins_c3 =  Math.Min (experience_norm_weight)
    }else{
        topsis_ins_c3 =  Math.Max (experience_norm_weight)
    }

6. jarak solusi ideal ke alternatif (dalam bentuk matriks)
7. hitung nilai preferensi V, di dalam array
8. perankingan
foreach (var item in keyvalue.OrderByDescending(key => key.Value))
{

} 

9. memunculkan hasil ke tampilan game

*/

/*
    ALUR PERHITUNGAN TOPSIS 2

1. membuat matriks keputusan (pake 3 array per kategori)

    // ambil data nilai taruh dalam array
    // ambil data waktu taruh dalam array
    // ambil data pengalaman taruh dalam array
    
    int experience [] = {}
    int score [] = {}
    int time [] = {}

    var arrList = new ArrayList ();
    arrList.AddRange (experience);
    arrList.AddRange (score);
    arrList.AddRange (time);

2. normalisasi matriks keputusan
    //menentukan nilai pembagi yaitu akar (penjumlahan (rating alt ^ 2) ) di setiap kriteria
    // sum semua rating alt kriteria 1 ^2
        for (int i = 0; i<score.length ; i++){
            sum_c1 += (score[i]*score[i]);
        }
    // pake library Math
    norm_div_c1 = Math.Sqrt (sum_c1);

    // membagi nilai dengan pembagi
    float norm_c1 [] = new float [];
    for (int i = 0; i<score.length ; i++){
        norm_c1 [i,0] = (score [i]/norm_div_c1);
    }

    // sum semua rating alt kriteria 2 ^2
        for (int i = 0; i<time.length ; i++){
            sum_c2 += (time[i]*time[i]);
        }
    // pake library Math
    norm_div_c2 = Math.Sqrt (sum_c2);

    // membagi nilai dengan pembagi
    float norm_c2 [] = new float [];
    for (int i = 0; i<time.length ; i++){
        norm_c2 [i,1] = (time [i]/norm_div_c2);
    }

    // sum semua rating alt kriteria 3 ^2
        for (int i = 0; i<experience.length ; i++){
            sum_c3 += (experience[i]*experience[i]);
        }
    // pake library Math
    norm_div_c3 = Math.Sqrt (sum_c3);

    // membagi nilai dengan pembagi
    norm_c3 [] = new float [];
    for (int i = 0; i<experience.length ; i++){
        norm_c3 [i,2] = (experience [i]/norm_div_c2);
    }

3. normalisasi matriks keputusan terbobot
    float norm_weight_c1 [] = new float [];
    for (int j = 0; j<score.length; j++){
                norm_weight_c1[j] = (norm_c1 [j] * 0.5);
        }
    }   
    float norm_weight_c2 [] = new float [];
    for (int j = 0; j<time.length; j++){
                norm_weight_c2[j] = (norm_c2 [j] * 0.3);
        }
    }   
    float norm_weight_c2 [] = new float [];
    for (int j = 0; j<experience.length; j++){
                norm_weight_c3[j] = (norm_c3 [j] * 0.2);
        }
    }   
4. solusi ideal positif
    // cek kategori kriteria
    if (c1_category == "benefit"){
        topsis_ips_c1 =  Math.Max (norm_weight_c1)
    }else{
        topsis_ips_c1 =  Math.Min (norm_weight_c1)
    }
    if (c2_category == "benefit"){
        topsis_ips_c2 =  Math.Max (norm_weight_c2)
    }else{
        topsis_ips_c2 =  Math.Min (norm_weight_c2)
    }
    if (c3_category == "benefit"){
        topsis_ips_c3 =  Math.Max (norm_weight_c3)
    }else{
        topsis_ips_c3 =  Math.Min (norm_weight_c3)
    }

5. solusi ideal negatif
// cek kategori kriteria
    if (c1_category == "benefit"){
        topsis_ins_c1 =  Math.Min (norm_weight_c1)
    }else{
        topsis_ins_c1 =  Math.Max (norm_weight_c1)
    }
    if (c2_category == "benefit"){
        topsis_ins_c2 =  Math.Min (norm_weight_c2)
    }else{
        topsis_ins_c2 =  Math.Max (norm_weight_c2)
    }
    if (c3_category == "benefit"){
        topsis_ins_c3 =  Math.Min (norm_weight_c3)
    }else{
        topsis_ins_c3 =  Math.Max (norm_weight_c3)
    }

6. jarak solusi ideal ke alternatif (dalam bentuk matriks)
// membuat variabel penampungan dalam array
    float topsis_dp []=new float [];
    float topsis_dn []=new float [];

// variabel penampungan sum distance per alternatif
    float topsis_sum_dp [] = new float []

    // penjumlahan
    for (int i = 0; i<alternatif.length ; i++){
        topsis_sum_dp [i] = ((topsis_ips_c1 - norm_weight_c1[i])*(topsis_ips_c1 - norm_weight_c1[i]))
        topsis_sum_dp [i] += ((topsis_ips_c2 - norm_weight_c2[i])*(topsis_ips_c2 - norm_weight_c2[i]))
        topsis_sum_dp [i] += ((topsis_ips_c3 - norm_weight_c3[i])*(topsis_ips_c3 - norm_weight_c3[i]))
    }
    // akar
    for (int i = 0; i<alternatif.length ; i++){
        topsis_dp [i] = Math.Sqrt(topsis_sum_dp[i]);
    }

// variabel penampungan sum distance per alternatif
    float topsis_sum_dn [] = new float []

    // penjumlahan
    for (int i = 0; i<alternatif.length ; i++){
        topsis_sum_dn [i] = ((norm_weight_c1[i] - topsis_ins_c1)*(norm_weight_c1[i] - topsis_ins_c1))
        topsis_sum_dn [i] = ((norm_weight_c2[i] - topsis_ins_c2)*(norm_weight_c2[i] - topsis_ins_c2))
        topsis_sum_dn [i] = ((norm_weight_c3[i] - topsis_ins_c3)*(norm_weight_c3[i] - topsis_ins_c3))
    }
    // akar
    for (int i = 0; i<alternatif.length ; i++){
        topsis_dn [i] = Math.Sqrt(topsis_sum_dn[i]);
    }   

7. hitung nilai preferensi V, di dalam array
// variabel penampungan preferensi
    float topsis_v [] = new float [];

    for (int i = 0; i<alternatif.length; i++){
        topsis_v [i] = (topsis_dn[i]/(topsis_dp[i]+topsis_dn[i]));
    }

// menggunakan dictionary sebagai pengganti array asosiatif
    Dictionary<int, string> topsis_v = new Dictionary<string, float>();

    for (int i = 0; i<alternatif.length; i++){
        val = (topsis_dn[i]/(topsis_dp[i]+topsis_dn[i]));
        topsis_v.Add(alternatif [i], val);
    }

8. perankingan
// mengurutkan dari yang terbesar menggunakan Linq
(di atas) using System.Linq; 

    var topsis_sorted = unsortedDict.OrderByDescending(x => x.Value).ToDictionary(x => x.Key, x => x.Value);

// tidak pake linq
    Dictionary<int, string> topsis_sorted = new Dictionary<string, float>();

// mengurutkan dari yang terbesar

    var topsis_sorted = new SortedDictionary <string, float>();

    foreach (topsis_v as sorted_v){
        topsis_sorted.Add(sorted_v.Key, sorted_v.Value);
    }

9. memunculkan hasil ke tampilan game
    for (int int i = 0; i<3; i++){
        print ("Materi: {topsis_sorted.Key} ; v: {topsis_sorted.Value} || ");
    }

*/


/*
    ALUR PERHITUNGAN POINTS PER MATERI

1. Memunculkan soal
    // if book_id = 1 {
        soal1_1.setactive
        soal1_2.setactive
        soal1_3.setactive
    } else book_id = 2 {
        soal2_1.setactive
        soal2_2.setactive
        soal2_3.setactive
    }dsb...
2. Waktu dimulai
3. jika player menyentuh collider jawaban (pencet f untuk memilih jawaban), maka
cek:
    if collider.layer mask = "correct answer"{
        // mengambil time pengerjaan dalam variabel timer
        life.setActive (true);
        switch (id_materi):
            case 1:
                skor_materi_1 += 70;
                waktu_materi_1 += timer;
            case 2:
                skor_materi_2 += 70;
                waktu_materi_2 += timer;
            case 3:
                skor_materi_3 += 70;
                waktu_materi_3 += timer;
    }
    else{
        // mengaktifkan semua npc untuk menyerang player;
        switch (id_materi):
            case 1:
                skor_materi_1 += 1;
                waktu_materi_1 += timer;
            case 2:
                skor_materi_2 += 1;
                waktu_materi_2 += timer;
            case 3:
                skor_materi_3 += 1;
                waktu_materi_3 += timer;
            }


*/

Soal controller
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System.IO;
using TMPro;
using UnityEngine.UI;
// using System.Runtime.Serialization.Formatters.Binary;

public class SoalController : MonoBehaviour
{
    // Start is called before the first frame update
    public TextMeshPro soalText;

    public string[] elementsNames;
    public string[] answerValues;
    public float correctAnswer;
    public bool status;
    public static List<int> i_store = new List<int>();

    void Awake()
    {
        Load();
    }
    void Start()
    {
        // if (status)
        // {
        //     status = false;
        ambilSoal();
        // }

    }

    // Update is called once per frame
    void Update()
    {
        // if (status)
        // {
        //     status = false;
        //     ambilSoal();
        // }
    }

    void ambilSoal()
    {
        // print(elementsNames.Length);
        int i = UnityEngine.Random.Range(0, elementsNames.Length);

        if (i_store.Count >= elementsNames.Length)
        {
            i_store.Clear();
        }

        int i_fix = cekDuplicate(i);


        // print(elementsNames[i_fix]);
        soalText.text = elementsNames[i_fix];
        // foreach (int item in i_store)
        // {
        //     print(item);
        // }
        // correctAnswer = answerValues[i];

    }
    public void Load()
    {
        if (File.Exists(Application.dataPath + "/data/soal_materi_1.txt"))
        {
            elementsNames = File.ReadAllLines(Application.dataPath + "/data/soal_materi_1.txt");
            // BinaryFormatter bf = new BinaryFormatter();

            // FileStream file = File.Open(Application.dataPath + "/data/soal_materi_1.txt", FileMode.Open);
            // PTInfo data = (PTInfo)bf.Deserialize(file);

            // file.Close();

            // elementsNames = data.elementsNames;
            // answerValues = data.answerValues;
        }
    }
    public int cekDuplicate(int i)
    {
        // print(elementsNames.Length.GetType());
        print("cek duplicate");
        if (i_store.Count < 1 || i_store.Count == elementsNames.Length - 1)
        {
            print(i_store.Count);
            i_store.Add(i);
            return i;
        }
        else
        {
            // print("cek duplicate foreach " + last_i);
            if (!i_store.Contains(i))
            {
                i_store.Add(i);
                return i;
                // print("cek duplicate foreach if");
            }
            else
            {
                // print("cek duplicate else");
                int new_i = UnityEngine.Random.Range(0, 10);
                print("have to check another number");
                return cekDuplicate(new_i);
            }
        }
        // return;
    }
}
